\section{Methodology}
\label{sec:method}
Our motivation comes when we see there are many of the threading staff make a
program inconsistent due to the concurrent running of the program. We have
found that data race is one of the very commonly happened error in the
multi-threaded program. Hence, we planed to implement a Thread Safety Violation
Detection (TSVD) mechanism in Java program.  

To implement the thread safety violations, we have five major steps such as
Java byte code instrumentation, trap checker,  trap setter,  delay settings and
trap clearer. Following discussion holds the details of each of the mechanism. 

\subsection{Java Byte Code Instrumentation}
Bytecode instrumentation is a process where compiled java classes are traced
and modified to add new functionalities \cite{}. Bytecode is an intermediate
language generated by the JVM from the source code. In this project, we need
byte code instrumentation to get the runtime information of a program to
identify all the call sites to relevant data structures' methods whose
thread-safety needs to be checked in the code. All these call sites are known
to as TSVD points. We deployed javaagent to instrument the bytecode of the
program and instrumented all these TSVD points. However, we will not check the
contexts like if these TSVD points are used within lock.

Our instrumentation technique instruments the binary by replacing each thread-safety
API with an automatically generated proxy call, which wraps the rest of the algorithm for checking trap, setting trap and so on.
%And onCall will decide if inject delay for the corresponding TSVD point.


\subsection{Find Dangerous Pairs}
In this project, danger pair means the conflicting interception point. It is
mentionworthy that each interception point is made of triplet i.e., object id
($obj_id$), thread id ($th_id$) and operation id ($op_id$). To find the dangerous pairs between two locations, for example $(loc_1 and loc_2)$, we take the triplet information for each location and measure the thread safety contract. The thread safety contract will be violated if the following conditions are satisfied. 

$obj_1 = obj_2$, $th_1 \neq th_2$ and atleast one operation is write operations.

\subsection{Happen Before Inference} In this section, we analyse the dependency
betweeen two interception points. To do so, we check the value for delay credit
of previously arrived same thread id. \shanto{It is noteworthy that, this delay
credit only sets in the clear trap mechanism when a object id is being removed from the global trap list  which indicates that ....  }  If the
value of delay credit is a non-zero positive number, then we remove these two
interception point from the danger lists and block the newly arrived
interception point until another one finishes it's sleep time or blocking time. 

\subsection{Trap Checker}
This section basically checks if the newly coming thread safety API (object id)
is already in our global trap list. If it happened, then the trap checker
extracts previously coming thread id ($th_1$) and operation id ($op_1$)  with the new thread id ($th_2$)
and its corresponding operation id ($op_2$). Now \Toolname{} will identify two locations such as $loc_1$ and $loc_2$ as conflicting or dangerous  pairs if it finds that the following conditions are satisfied. 
$obj_1 == obj_2$, $th_1 \neq th_2$ and atleast any of the operations such as $op_1$ or $op_2$ are write operation.


\subsection{Trap Setter}
Trap setter set the trap for the thread safety API object id and store it in the global trap list. Finally, it sets a flag to indicate the trap status.

\subsection{Delay Setting}
Currently, in our project, we manually set the delay time for each thread by 200 milliseconds. 

\subsection{Trap clearer}
The main ojective of the trap clearer is to remove the object id (i.e., thread safety API) from the global trap list. Then we will add some delay credit on the newly coming interception point with some fixed infer size  to .... Initially the infer size is set to 5. Now we also check the time difference happened between the last thread interception point and recently coming interception point. If the time difference is less than our threshold value, we blocked the newly coming thread safety API. Finally, we make the status of active trap as false.



%Here is the introduction text, where we describe our \Toolname{} 
%along with our \TotalResults{} results.\Space{ The text in here is whited
%out in case we are over and need to cut text.}

\Comment{This is a comment, will not be rendered in PDF.}


We found one \bug{} and it was awesome.
We found two \bug{}s and it was even more awesome.
